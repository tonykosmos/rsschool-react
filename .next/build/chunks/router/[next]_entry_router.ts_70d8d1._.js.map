{
  "version": 3,
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["/turbopack/[next]/entry/router.ts"],"sourcesContent":["import type { Ipc, StructuredError } from '@vercel/turbopack-node/ipc/index'\r\nimport type { IncomingMessage, ServerResponse } from 'node:http'\r\nimport { Buffer } from 'node:buffer'\r\nimport { createServer, makeRequest } from '../internal/server'\r\nimport { toPairs } from '../internal/headers'\r\nimport {\r\n  makeResolver,\r\n  RouteResult,\r\n  ServerAddress,\r\n} from 'next/dist/server/lib/route-resolver'\r\nimport loadConfig from 'next/dist/server/config'\r\nimport { PHASE_DEVELOPMENT_SERVER } from 'next/dist/shared/lib/constants'\r\n\r\nimport 'next/dist/server/node-polyfill-fetch.js'\r\n\r\nimport middlewareChunkGroup from 'MIDDLEWARE_CHUNK_GROUP'\r\nimport middlewareConfig from 'MIDDLEWARE_CONFIG'\r\n\r\ntype RouterRequest = {\r\n  method: string\r\n  pathname: string\r\n  rawHeaders: [string, string][]\r\n  rawQuery: string\r\n  body: number[][]\r\n}\r\n\r\ntype IpcOutgoingMessage = {\r\n  type: 'value'\r\n  data: string | Buffer\r\n}\r\n\r\ntype MessageData =\r\n  | { type: 'middleware-headers'; data: MiddlewareHeadersResponse }\r\n  | { type: 'middleware-body'; data: Uint8Array }\r\n  | {\r\n      type: 'rewrite'\r\n      data: RewriteResponse\r\n    }\r\n  | {\r\n      type: 'error'\r\n      error: StructuredError\r\n    }\r\n  | { type: 'none' }\r\n\r\ntype RewriteResponse = {\r\n  url: string\r\n  headers: [string, string][]\r\n}\r\n\r\ntype MiddlewareHeadersResponse = {\r\n  statusCode: number\r\n  headers: [string, string][]\r\n}\r\n\r\nlet resolveRouteMemo: Promise<\r\n  (req: IncomingMessage, res: ServerResponse) => Promise<void>\r\n>\r\n\r\nasync function getResolveRoute(\r\n  dir: string,\r\n  serverAddr: Partial<ServerAddress>\r\n): ReturnType<\r\n  typeof import('next/dist/server/lib/route-resolver').makeResolver\r\n> {\r\n  const nextConfig = await loadConfig(\r\n    PHASE_DEVELOPMENT_SERVER,\r\n    process.cwd(),\r\n    undefined,\r\n    undefined,\r\n    true\r\n  )\r\n  const middlewareCfg = {\r\n    files: middlewareChunkGroup.filter((f) => /\\.[mc]?js$/.test(f)),\r\n    matcher: middlewareConfig.matcher,\r\n  }\r\n\r\n  return await makeResolver(dir, nextConfig, middlewareCfg, serverAddr)\r\n}\r\n\r\nexport default async function route(\r\n  ipc: Ipc<RouterRequest, IpcOutgoingMessage>,\r\n  routerRequest: RouterRequest,\r\n  dir: string,\r\n  serverAddr: Partial<ServerAddress>\r\n) {\r\n  const [resolveRoute, server] = await Promise.all([\r\n    (resolveRouteMemo ??= getResolveRoute(dir, serverAddr)),\r\n    createServer(),\r\n  ])\r\n\r\n  try {\r\n    const {\r\n      clientRequest,\r\n      clientResponsePromise,\r\n      serverRequest,\r\n      serverResponse,\r\n    } = await makeRequest(\r\n      server,\r\n      routerRequest.method,\r\n      routerRequest.pathname,\r\n      routerRequest.rawQuery,\r\n      routerRequest.rawHeaders\r\n    )\r\n\r\n    const body = Buffer.concat(\r\n      routerRequest.body.map((arr) => Buffer.from(arr))\r\n    )\r\n\r\n    // Send the clientRequest, so the server parses everything. We can then pass\r\n    // the serverRequest to Next.js to handle.\r\n    clientRequest.end(body)\r\n\r\n    // The route promise must not block us from starting the client response\r\n    // handling, so we cannot await it yet. By making the call, we allow\r\n    // Next.js to start writing to the response whenever it's ready.\r\n    const routePromise = resolveRoute(serverRequest, serverResponse)\r\n\r\n    // Now that the Next.js has started processing the route, the\r\n    // clientResponsePromise will resolve once they write data and then we can\r\n    // begin streaming.\r\n    // We again cannot block on the clientResponsePromise, because an error may\r\n    // occur in the routePromise while we're waiting.\r\n    const responsePromise = clientResponsePromise.then((c) =>\r\n      handleClientResponse(ipc, c)\r\n    )\r\n\r\n    // Now that both promises are in progress, we await both so that a\r\n    // rejection in either will end the routing.\r\n    const [response] = await Promise.all([responsePromise, routePromise])\r\n\r\n    server.close()\r\n    return response\r\n  } catch (e) {\r\n    // Server doesn't need to be closed, because the sendError will terminate\r\n    // the process.\r\n    ipc.sendError(e as Error)\r\n  }\r\n}\r\n\r\nasync function handleClientResponse(\r\n  ipc: Ipc<RouterRequest, IpcOutgoingMessage>,\r\n  clientResponse: IncomingMessage\r\n): Promise<MessageData | void> {\r\n  if (clientResponse.headers['x-nextjs-route-result'] === '1') {\r\n    clientResponse.setEncoding('utf8')\r\n    // We're either a redirect or a rewrite\r\n    let buffer = ''\r\n    for await (const chunk of clientResponse) {\r\n      buffer += chunk\r\n    }\r\n\r\n    const data = JSON.parse(buffer) as RouteResult\r\n\r\n    switch (data.type) {\r\n      case 'none':\r\n        return {\r\n          type: 'none',\r\n        }\r\n      case 'error':\r\n        return {\r\n          type: 'error',\r\n          error: data.error,\r\n        }\r\n      case 'rewrite':\r\n        return {\r\n          type: 'rewrite',\r\n          data: {\r\n            url: data.url,\r\n            headers: Object.entries(data.headers)\r\n              .filter(([, val]) => val != null)\r\n              .map(([name, value]) => [name, value!.toString()]),\r\n          },\r\n        }\r\n      default:\r\n        // @ts-expect-error data.type is never\r\n        throw new Error(`unknown route result type: ${data.type}`)\r\n    }\r\n  }\r\n\r\n  const responseHeaders: MiddlewareHeadersResponse = {\r\n    statusCode: clientResponse.statusCode!,\r\n    headers: toPairs(clientResponse.rawHeaders),\r\n  }\r\n\r\n  await ipc.send({\r\n    type: 'value',\r\n    data: JSON.stringify({\r\n      type: 'middleware-headers',\r\n      data: responseHeaders,\r\n    }),\r\n  })\r\n\r\n  for await (const chunk of clientResponse) {\r\n    await ipc.send({\r\n      type: 'value',\r\n      data: JSON.stringify({\r\n        type: 'middleware-body',\r\n        data: (chunk as Buffer).toJSON().data,\r\n      }),\r\n    })\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAsDA,IAAI;AAIJ,eAAe,gBACb,GAAW,EACX,UAAkC,EAGlC;IACA,MAAM,aAAa,MAAM,sKAEvB,QAAQ,GAAG,IACX,WACA,WACA,IAAI;IAEN,MAAM,gBAAgB;QACpB,OAAO,kGAAqB,MAAM,CAAC,CAAC,IAAM,aAAa,IAAI,CAAC;QAC5D,SAAS,yGAAiB,OAAO;IACnC;IAEA,OAAO,MAAM,4FAAa,KAAK,YAAY,eAAe;AAC5D;AAEe,eAAe,MAC5B,GAA2C,EAC3C,aAA4B,EAC5B,GAAW,EACX,UAAkC,EAClC;IACA,MAAM,CAAC,cAAc,OAAO,GAAG,MAAM,QAAQ,GAAG,CAAC;QAC9C,qBAAqB,gBAAgB,KAAK;QAC3C;KACD;IAED,IAAI;QACF,MAAM,EACJ,cAAa,EACb,sBAAqB,EACrB,cAAa,EACb,eAAc,EACf,GAAG,MAAM,2GACR,QACA,cAAc,MAAM,EACpB,cAAc,QAAQ,EACtB,cAAc,QAAQ,EACtB,cAAc,UAAU;QAG1B,MAAM,OAAO,kDAAO,MAAM,CACxB,cAAc,IAAI,CAAC,GAAG,CAAC,CAAC,MAAQ,kDAAO,IAAI,CAAC;QAK9C,cAAc,GAAG,CAAC;QAKlB,MAAM,eAAe,aAAa,eAAe;QAOjD,MAAM,kBAAkB,sBAAsB,IAAI,CAAC,CAAC,IAClD,qBAAqB,KAAK;QAK5B,MAAM,CAAC,SAAS,GAAG,MAAM,QAAQ,GAAG,CAAC;YAAC;YAAiB;SAAa;QAEpE,OAAO,KAAK;QACZ,OAAO;IACT,EAAE,OAAO,GAAG;QAGV,IAAI,SAAS,CAAC;IAChB;AACF;AAEA,eAAe,qBACb,GAA2C,EAC3C,cAA+B,EACF;IAC7B,IAAI,eAAe,OAAO,CAAC,wBAAwB,KAAK,KAAK;QAC3D,eAAe,WAAW,CAAC;QAE3B,IAAI,SAAS;QACb,WAAW,MAAM,SAAS,eAAgB;YACxC,UAAU;QACZ;QAEA,MAAM,OAAO,KAAK,KAAK,CAAC;QAExB,OAAQ,KAAK,IAAI;YACf,KAAK;gBACH,OAAO;oBACL,MAAM;gBACR;YACF,KAAK;gBACH,OAAO;oBACL,MAAM;oBACN,OAAO,KAAK,KAAK;gBACnB;YACF,KAAK;gBACH,OAAO;oBACL,MAAM;oBACN,MAAM;wBACJ,KAAK,KAAK,GAAG;wBACb,SAAS,OAAO,OAAO,CAAC,KAAK,OAAO,EACjC,MAAM,CAAC,CAAC,GAAG,IAAI,GAAK,OAAO,IAAI,EAC/B,GAAG,CAAC,CAAC,CAAC,MAAM,MAAM,GAAK;gCAAC;gCAAM,MAAO,QAAQ;6BAAG;oBACrD;gBACF;YACF;gBAEE,MAAM,IAAI,MAAM,CAAC,2BAA2B,EAAE,KAAK,IAAI,CAAC,CAAC,EAAC;QAC9D;IACF,CAAC;IAED,MAAM,kBAA6C;QACjD,YAAY,eAAe,UAAU;QACrC,SAAS,wGAAQ,eAAe,UAAU;IAC5C;IAEA,MAAM,IAAI,IAAI,CAAC;QACb,MAAM;QACN,MAAM,KAAK,SAAS,CAAC;YACnB,MAAM;YACN,MAAM;QACR;IACF;IAEA,WAAW,MAAM,SAAS,eAAgB;QACxC,MAAM,IAAI,IAAI,CAAC;YACb,MAAM;YACN,MAAM,KAAK,SAAS,CAAC;gBACnB,MAAM;gBACN,MAAM,AAAC,MAAiB,MAAM,GAAG,IAAI;YACvC;QACF;IACF;AACF"}},
    {"offset": {"line": 110, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}