{
  "version": 3,
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["/turbopack/[next]/internal/headers.ts"],"sourcesContent":["/**\r\n * Converts an array of raw header entries to a map of header names to values.\r\n */\r\nexport function headersFromEntries(\r\n  entries: Array<[string, string]>\r\n): Record<string, string | string[]> {\r\n  const headers: Record<string, string | string[]> = Object.create(null)\r\n  for (const [key, value] of entries) {\r\n    if (key in headers) {\r\n      const prevValue = headers[key]\r\n      if (typeof prevValue === 'string') {\r\n        headers[key] = [prevValue, value]\r\n      } else {\r\n        prevValue.push(value)\r\n      }\r\n    } else {\r\n      headers[key] = value\r\n    }\r\n  }\r\n  return headers\r\n}\r\n\r\n/**\r\n * Transforms an array of elements into an array of pairs of elements.\r\n *\r\n * ## Example\r\n *\r\n * ```ts\r\n * toPairs([\"a\", \"b\", \"c\", \"d\"]) // => [[\"a\", \"b\"], [\"c\", \"d\"]]\r\n * ```\r\n */\r\nexport function toPairs<T>(arr: T[]): Array<[T, T]> {\r\n  if (arr.length % 2 !== 0) {\r\n    throw new Error('toPairs: expected an even number of elements')\r\n  }\r\n\r\n  const pairs: Array<[T, T]> = []\r\n  for (let i = 0; i < arr.length; i += 2) {\r\n    pairs.push([arr[i], arr[i + 1]])\r\n  }\r\n\r\n  return pairs\r\n}\r\n"],"names":[],"mappings":";;;;AAGO,SAAS,mBACd,OAAgC,EACG;IACnC,MAAM,UAA6C,OAAO,MAAM,CAAC,IAAI;IACrE,KAAK,MAAM,CAAC,KAAK,MAAM,IAAI,QAAS;QAClC,IAAI,OAAO,SAAS;YAClB,MAAM,YAAY,OAAO,CAAC,IAAI;YAC9B,IAAI,OAAO,cAAc,UAAU;gBACjC,OAAO,CAAC,IAAI,GAAG;oBAAC;oBAAW;iBAAM;YACnC,OAAO;gBACL,UAAU,IAAI,CAAC;YACjB,CAAC;QACH,OAAO;YACL,OAAO,CAAC,IAAI,GAAG;QACjB,CAAC;IACH;IACA,OAAO;AACT;AAWO,SAAS,QAAW,GAAQ,EAAiB;IAClD,IAAI,IAAI,MAAM,GAAG,MAAM,GAAG;QACxB,MAAM,IAAI,MAAM,gDAA+C;IACjE,CAAC;IAED,MAAM,QAAuB,EAAE;IAC/B,IAAK,IAAI,IAAI,GAAG,IAAI,IAAI,MAAM,EAAE,KAAK,EAAG;QACtC,MAAM,IAAI,CAAC;YAAC,GAAG,CAAC,EAAE;YAAE,GAAG,CAAC,IAAI,EAAE;SAAC;IACjC;IAEA,OAAO;AACT"}},
    {"offset": {"line": 40, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}},
    {"offset": {"line": 44, "column": 0}, "map": {"version":3,"sources":["/turbopack/[next]/internal/server.ts"],"sourcesContent":["import type { ClientRequest, IncomingMessage, Server } from 'node:http'\r\nimport type { AddressInfo } from 'node:net'\r\nimport http, { ServerResponse } from 'node:http'\r\nimport { headersFromEntries } from './headers'\r\n\r\n/**\r\n * Creates a server that listens a random port.\r\n */\r\nexport function createServer(): Promise<Server> {\r\n  return new Promise((resolve) => {\r\n    const server = http.createServer()\r\n    server.listen(0, () => {\r\n      resolve(server)\r\n    })\r\n  })\r\n}\r\n\r\n/**\r\n * Creates a request to a server, and returns the (req, res) pairs from both\r\n * the client's and server's perspective.\r\n */\r\nexport function makeRequest(\r\n  server: Server,\r\n  method: string,\r\n  path: string,\r\n  rawQuery?: string,\r\n  rawHeaders?: [string, string][]\r\n): Promise<{\r\n  clientRequest: ClientRequest\r\n  clientResponsePromise: Promise<IncomingMessage>\r\n  serverRequest: IncomingMessage\r\n  serverResponse: ServerResponse<IncomingMessage>\r\n}> {\r\n  return new Promise((resolve, reject) => {\r\n    let clientRequest: ClientRequest | null = null\r\n    let clientResponseResolve: (value: IncomingMessage) => void\r\n    let clientResponseReject: (error: Error) => void\r\n    const clientResponsePromise = new Promise<IncomingMessage>(\r\n      (resolve, reject) => {\r\n        clientResponseResolve = resolve\r\n        clientResponseReject = reject\r\n      }\r\n    )\r\n    let serverRequest: IncomingMessage | null = null\r\n    let serverResponse: ServerResponse<IncomingMessage> | null = null\r\n\r\n    const maybeResolve = () => {\r\n      if (\r\n        clientRequest != null &&\r\n        serverRequest != null &&\r\n        serverResponse != null\r\n      ) {\r\n        cleanup()\r\n        resolve({\r\n          clientRequest,\r\n          clientResponsePromise,\r\n          serverRequest,\r\n          serverResponse,\r\n        })\r\n      }\r\n    }\r\n\r\n    const cleanup = () => {\r\n      server.removeListener('error', errorListener)\r\n      server.removeListener('request', requestListener)\r\n    }\r\n\r\n    const errorListener = (err: Error) => {\r\n      cleanup()\r\n      reject(err)\r\n    }\r\n\r\n    const requestListener = (\r\n      req: IncomingMessage,\r\n      res: ServerResponse<IncomingMessage>\r\n    ) => {\r\n      serverRequest = req\r\n      serverResponse = res\r\n      maybeResolve()\r\n    }\r\n\r\n    const cleanupClientResponse = () => {\r\n      if (clientRequest != null) {\r\n        clientRequest.removeListener('response', responseListener)\r\n        clientRequest.removeListener('error', clientResponseErrorListener)\r\n      }\r\n    }\r\n\r\n    const clientResponseErrorListener = (err: Error) => {\r\n      cleanupClientResponse()\r\n      clientResponseReject(err)\r\n    }\r\n\r\n    const responseListener = (res: IncomingMessage) => {\r\n      cleanupClientResponse()\r\n      clientResponseResolve(res)\r\n    }\r\n\r\n    server.once('request', requestListener)\r\n    server.once('error', errorListener)\r\n\r\n    const address = server.address() as AddressInfo\r\n\r\n    clientRequest = http.request({\r\n      host: 'localhost',\r\n      port: address.port,\r\n      method,\r\n      path:\r\n        rawQuery != null && rawQuery.length > 0 ? `${path}?${rawQuery}` : path,\r\n      headers: rawHeaders != null ? headersFromEntries(rawHeaders) : undefined,\r\n    })\r\n\r\n    // Otherwise Node.js waits for the first chunk of data to be written before sending the request.\r\n    clientRequest.flushHeaders()\r\n\r\n    clientRequest.once('response', responseListener)\r\n    clientRequest.once('error', clientResponseErrorListener)\r\n  })\r\n}\r\n"],"names":[],"mappings":";;;;;;;;;AAQO,SAAS,eAAgC;IAC9C,OAAO,IAAI,QAAQ,CAAC,UAAY;QAC9B,MAAM,SAAS,iDAAK,YAAY;QAChC,OAAO,MAAM,CAAC,GAAG,IAAM;YACrB,QAAQ;QACV;IACF;AACF;AAMO,SAAS,YACd,MAAc,EACd,MAAc,EACd,IAAY,EACZ,QAAiB,EACjB,UAA+B,EAM9B;IACD,OAAO,IAAI,QAAQ,CAAC,SAAS,SAAW;QACtC,IAAI,gBAAsC,IAAI;QAC9C,IAAI;QACJ,IAAI;QACJ,MAAM,wBAAwB,IAAI,QAChC,CAAC,SAAS,SAAW;YACnB,wBAAwB;YACxB,uBAAuB;QACzB;QAEF,IAAI,gBAAwC,IAAI;QAChD,IAAI,iBAAyD,IAAI;QAEjE,MAAM,eAAe,IAAM;YACzB,IACE,iBAAiB,IAAI,IACrB,iBAAiB,IAAI,IACrB,kBAAkB,IAAI,EACtB;gBACA;gBACA,QAAQ;oBACN;oBACA;oBACA;oBACA;gBACF;YACF,CAAC;QACH;QAEA,MAAM,UAAU,IAAM;YACpB,OAAO,cAAc,CAAC,SAAS;YAC/B,OAAO,cAAc,CAAC,WAAW;QACnC;QAEA,MAAM,gBAAgB,CAAC,MAAe;YACpC;YACA,OAAO;QACT;QAEA,MAAM,kBAAkB,CACtB,KACA,MACG;YACH,gBAAgB;YAChB,iBAAiB;YACjB;QACF;QAEA,MAAM,wBAAwB,IAAM;YAClC,IAAI,iBAAiB,IAAI,EAAE;gBACzB,cAAc,cAAc,CAAC,YAAY;gBACzC,cAAc,cAAc,CAAC,SAAS;YACxC,CAAC;QACH;QAEA,MAAM,8BAA8B,CAAC,MAAe;YAClD;YACA,qBAAqB;QACvB;QAEA,MAAM,mBAAmB,CAAC,MAAyB;YACjD;YACA,sBAAsB;QACxB;QAEA,OAAO,IAAI,CAAC,WAAW;QACvB,OAAO,IAAI,CAAC,SAAS;QAErB,MAAM,UAAU,OAAO,OAAO;QAE9B,gBAAgB,iDAAK,OAAO,CAAC;YAC3B,MAAM;YACN,MAAM,QAAQ,IAAI;YAClB;YACA,MACE,YAAY,IAAI,IAAI,SAAS,MAAM,GAAG,IAAI,CAAC,EAAE,KAAK,CAAC,EAAE,SAAS,CAAC,GAAG,IAAI;YACxE,SAAS,cAAc,IAAI,GAAG,mHAAmB,cAAc,SAAS;QAC1E;QAGA,cAAc,YAAY;QAE1B,cAAc,IAAI,CAAC,YAAY;QAC/B,cAAc,IAAI,CAAC,SAAS;IAC9B;AACF"}},
    {"offset": {"line": 125, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"A"}}]
}